<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Barford Handicap Calculator - v1.0.3</title>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
</head>
<body>

<h1 style="color:red;">ğŸŒï¸â€â™‚ï¸ THIS IS THE NEW VERSION (v1.0.3) â€” Best 5 Rounds Logic ADDED ğŸŒï¸â€â™‚ï¸</h1>
<p>If you can see this red message, youâ€™re running the updated logic with totals.</p>

<p>
  Password: <input type="password" id="pw">
  <button onclick="unlock()">Unlock</button>
  <button onclick="lock()">Lock</button>
</p>

<p>
  <button onclick="calculate()">Calculate Round</button>
  <button onclick="nextRound()">Next Round</button>
  <button onclick="prevRound()">Prev Round</button>
  <button onclick="addPlayer()">Add Player</button>
  <button onclick="resetLeague()">Reset</button>
</p>

<p id="roundInfo">Round 1 of 7</p>

<pre id="output">Loading players...</pre>

<script>
console.log("â›³ NEW VERSION v1.0.3 LOADED â€” Best-5-Round Totals Enabled");

// ---------- PUBLIC TEST CREDENTIALS ----------
const SUPABASE_URL = "https://tzzkgfehtnuizamzlbgr.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR6emtnZmVodG51aXphbXpsYmdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0MzY5ODAsImV4cCI6MjA3ODAxMjk4MH0.2mf4RMbJJvPo0NApywlrDyHuqAMfMyEWxgOS2ZSP4KQ";
// ---------------------------------------------

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

const PASSWORD = "westbrom1997";
let unlocked = false;
let currentRound = 1;
const maxRounds = 7;
let players = [];

// Load all players
async function loadPlayers() {
  const { data, error } = await supabase
    .from("scores")
    .select("*")
    .order("id", { ascending: true });
  if (error) return console.error("Supabase error:", error);
  players = data || [];
  display();
}

// Realtime updates
supabase.channel("scores")
  .on("postgres_changes", { event: "*", schema: "public", table: "scores" }, loadPlayers)
  .subscribe();

// Display
function display() {
  let text = "PLAYER | HCP | POINTS | ADJ | NEXT | TOTAL\n";
  text += "---------------------------------------------\n";
  for (const p of players) {
    text += `${p.player || "?"} | ${p.handicap ?? "-"} | ${p.points ?? "-"} | ${p.adj ?? "-"} | ${p.next_handicap ?? "-"} | ${p.total ?? "-"}\n`;
  }
  document.getElementById("output").textContent = text;
  document.getElementById("roundInfo").textContent = "Round " + currentRound + " of " + maxRounds;
}

// Handicap adjustment rules
function getAdj(points) {
  if (points >= 43) return -3;
  if (points >= 38) return -2;
  if (points >= 31) return -1;
  if (points >= 26) return 0;
  if (points >= 21) return 1;
  if (points >= 16) return 2;
  return 3;
}

// Calculate totals for each player (best 5 rounds)
async function updateTotals() {
  // Fetch all rounds for each player
  for (const p of players) {
    const { data, error } = await supabase
      .from("scores")
      .select("points")
      .eq("player", p.player);

    if (error) { console.error(error); continue; }

    const pointsArray = (data || [])
      .map(r => r.points)
      .filter(v => v !== null && !isNaN(v))
      .sort((a,b)=>b-a)
      .slice(0,5);

    const total = pointsArray.reduce((a,b)=>a+b,0);

    await supabase.from("scores")
      .update({ total })
      .eq("id", p.id);
  }
  loadPlayers();
}

// Calculate round
async function calculate() {
  if (!unlocked) return alert("Unlock first.");
  for (const p of players) {
    const raw = prompt("Enter points for " + p.player + ":", p.points ?? "");
    const pts = raw === "" ? null : parseInt(raw);
    const adj = pts === null ? null : getAdj(pts);
    const topScore = Math.max(...players.map(x => x.points ?? -Infinity));
    const finalAdj = (pts === topScore && pts !== null) ? adj - 1 : adj;
    const nextHcp = pts === null ? p.handicap : Math.max(0, Math.round((p.handicap ?? 0) + finalAdj));

    await supabase.from("scores").update({
      points: pts,
      adj: finalAdj,
      next_handicap: nextHcp,
      round: currentRound,
      updated_at: new Date().toISOString()
    }).eq("id", p.id);
  }

  alert("âœ… Round calculated. Now updating totals...");
  await updateTotals();
}

// Next round
async function nextRound() {
  if (currentRound >= maxRounds) return alert("League finished.");
  currentRound++;
  for (const p of players) {
    const newHcp = p.next_handicap ?? p.handicap;
    await supabase.from("scores").update({
      handicap: newHcp,
      points: null,
      adj: null,
      round: currentRound
    }).eq("id", p.id);
  }
  unlocked = false;
  loadPlayers();
}

// Previous round
function prevRound() {
  if (currentRound > 1) currentRound--;
  display();
}

// Locking
function unlock() {
  const val = document.getElementById("pw").value;
  if (val === PASSWORD) { unlocked = true; alert("Unlocked v1.0.3"); }
  else alert("Wrong password");
}
function lock() { unlocked = false; alert("Locked"); }

// Add player
async function addPlayer() {
  const name = prompt("Enter player name:");
  if (!name) return;
  await supabase.from("scores").insert([
    { player: name, handicap: 0, points: null, adj: null, next_handicap: 0, total: 0, round: currentRound }
  ]);
  loadPlayers();
}

// Reset league
async function resetLeague() {
  const pw = prompt("Enter password:");
  if (pw !== PASSWORD) return alert("Wrong password");
  await supabase.from("scores").delete().neq("id", 0);
  currentRound = 1;
  loadPlayers();
}

// Start
loadPlayers();
</script>

</body>
</html>
