<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scores & Handicap Calculator | Barford Golf Society</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --green:#005a2b;
      --gold:#d4af37;
      --cream:#f7f7f5;
      --dark-bg:#1e1e1e;
      --dark-card:#2a2a2a;
      --text-light:#f7f7f5;
    }

    body{
      font-family:"Inter",sans-serif;
      margin:0;
      background:linear-gradient(135deg,var(--cream)40%,#e9f2e9);
      color:#1b1b1b;
      transition:background .4s,color .4s;
    }
    body.dark-mode{background:var(--dark-bg);color:var(--text-light);}

    /* HEADER */
    .site-header{
      background:var(--green);
      color:var(--gold);
      padding:15px 0;
      border-bottom:3px solid var(--gold);
    }
    .header-container{
      display:flex;justify-content:space-between;align-items:center;
      max-width:1200px;margin:auto;padding:0 20px;
    }
    .site-title{font-size:1.5em;color:var(--gold);margin:0;}
    .site-nav ul{list-style:none;display:flex;gap:20px;margin:0;padding:0;}
    .site-nav a{color:white;text-decoration:none;font-weight:600;}
    .site-nav a.active,.site-nav a:hover{color:var(--gold);}

    /* LEADERBOARD */
    .leaderboard-banner{
      text-align:center;
      background:var(--gold);
      color:#1b1b1b;
      font-weight:700;
      padding:10px;
      border-bottom:2px solid var(--green);
    }

    /* SCORES CONTAINER */
    .scores-container{
      max-width:1200px;
      margin:30px auto;
      background:#fff;
      border-radius:12px;
      box-shadow:0 5px 20px rgba(0,0,0,.1);
      overflow:hidden;
      transition:background .4s,color .4s;
    }
    body.dark-mode .scores-container{
      background:var(--dark-card);
      color:var(--text-light);
      box-shadow:0 4px 15px rgba(255,255,255,.1);
    }

    header.calc-header{
      background:linear-gradient(to right,var(--green),#0a6b34);
      color:var(--gold);
      text-align:center;
      padding:20px;
      font-size:1.8rem;
      font-weight:700;
    }

    /* TOPBAR BUTTONS */
    .topbar{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:8px;
      padding:16px;
      background:#fff;
      box-shadow:0 3px 10px rgba(0,0,0,.05);
      position:sticky;top:0;z-index:10;
    }
    body.dark-mode .topbar{background:var(--dark-card);}
    input[type=password],input[type=number]{
      border-radius:6px;border:1px solid #ccc;padding:8px;
      transition:border .2s,box-shadow .2s;
    }
    input:focus{
      border-color:var(--gold);
      box-shadow:0 0 5px rgba(212,175,55,.4);
      outline:none;
    }

    .btn{
      padding:8px 12px;border:none;border-radius:8px;
      font-weight:600;cursor:pointer;
      transition:all .25s ease;font-size:.9rem;
    }
    .btn:hover{transform:translateY(-2px);box-shadow:0 2px 8px rgba(0,0,0,.15);}
    .btn-unlock{background:var(--gold);color:#1b1b1b;}
    .btn-lock{background:var(--green);color:#fff;}
    .btn-calc{background:#ffcc00;color:#1b1b1b;}
    .btn-next,.btn-prev{background:#ddd;color:#1b1b1b;}
    .btn-add{background:#c0c0c0;color:#1b1b1b;}
    .btn-download{background:var(--green);color:var(--gold);}
    .btn-theme{background:none;border:1px solid var(--gold);color:var(--gold);}
    .btn-reset{background:#b30000;color:#fff;}

    /* TABLE */
    main{padding:20px;}
    #tableContainer{position:relative;} /* anchor overlay & keep buttons clickable */
    table{width:100%;border-collapse:collapse;background:#fff;border-radius:12px;overflow:hidden;}
    body.dark-mode table{background:var(--dark-card);}
    th,td{padding:12px;text-align:center;border-bottom:1px solid #f1f1f1;}
    th{background:var(--green);color:var(--gold);text-transform:uppercase;}
    tbody tr:nth-child(even){background:#f8f8f8;}
    body.dark-mode tbody tr:nth-child(even){background:#333;}

    /* FOOTER */
    footer{
      text-align:center;
      background:var(--green);
      color:var(--gold);
      padding:20px;
      border-top:4px solid var(--gold);
      margin-top:40px;
    }

    /* FROSTED BLUR ‚Äî table-only, never blocks buttons */
    .blur-overlay{
      position:absolute;
      inset:0;
      background:rgba(255,255,255,.45);
      backdrop-filter:blur(22px) brightness(.9);
      -webkit-backdrop-filter:blur(22px) brightness(.9);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:5;                  /* topbar is z=10 */
      color:var(--green);
      font-size:1.4rem;
      font-weight:700;
      text-align:center;
      pointer-events:none;        /* clicks pass through */
      border-radius:12px;
      opacity:0;
      transition:opacity .35s ease;
    }
    .blur-overlay.active{display:flex;opacity:1;}

    /* Simple modal for final results */
    .modal-backdrop{
      position:fixed;inset:0;background:rgba(0,0,0,.5);
      display:none;justify-content:center;align-items:center;z-index:1200;
    }
    .modal-backdrop.active{display:flex;}
    .modal{
      background:#fff;border-radius:12px;max-width:520px;width:92%;
      padding:18px 20px;box-shadow:0 12px 30px rgba(0,0,0,.25);
    }
    .modal h3{margin:0 0 10px;color:var(--green);}
    .modal pre{
      background:#f7f7f7;border-radius:8px;padding:12px;max-height:50vh;overflow:auto;
    }
    .modal .actions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px;}
    .modal .btn{font-size:.85rem}
    body.dark-mode .modal{background:var(--dark-card);color:var(--text-light);}
    body.dark-mode .modal pre{background:#333;color:#eee;}
  </style>
</head>

<body>
  <header class="site-header">
    <div class="header-container">
      <h1 class="site-title">Barford Golf Society</h1>
      <nav class="site-nav">
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="events.html">Events</a></li>
          <li><a href="scores.html" class="active">Scores</a></li>
          <li><a href="admin.html">Admin</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <div id="leaderboard" class="leaderboard-banner">üèåÔ∏è Leaderboard loading...</div>

  <div class="scores-container">
    <header class="calc-header">Golf Society Handicap Calculator</header>

    <div class="topbar">
      <input type="password" id="pwInput" placeholder="Enter password">
      <button class="btn btn-unlock" onclick="unlockInputs()">Unlock</button>
      <button class="btn btn-lock" onclick="lockInputs()">Lock</button>
      <button class="btn btn-calc" onclick="calculateHandicaps()">Calculate</button>
      <button class="btn btn-prev" onclick="prevRound()">‚óÄ Prev</button>
      <button class="btn btn-next" onclick="nextRound()">Next ‚ñ∂</button>
      <button class="btn btn-add" onclick="addPlayer()">+ Player</button>
      <button class="btn btn-download" onclick="downloadCsv()">Download CSV</button>
      <button class="btn btn-reset" onclick="resetSeason()">Reset Season</button>
      <button class="btn btn-theme" onclick="toggleTheme()">üåì</button>
    </div>

    <main>
      <div class="round-info">
        <h3 id="roundHeader">Round 1 of 7</h3>
      </div>
      <div id="tableContainer">
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Player</th>
              <th id="hcpHeader">Round 1 HCP</th>
              <th>Points</th>
              <th>Adj</th>
              <th id="newHcpHeader">Next HCP</th>
              <th>Total (Best 5)</th>
              <th>DNP</th>
            </tr>
          </thead>
          <tbody id="playersTable"></tbody>
        </table>

        <!-- Frosted blur ONLY over the table area -->
        <div id="blurOverlay" class="blur-overlay">üîí Scores hidden until unlocked</div>
      </div>
    </main>
  </div>

  <!-- Modal for final results -->
  <div id="resultsBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="resultsTitle">
    <div class="modal">
      <h3 id="resultsTitle">üèÜ Final Results</h3>
      <pre id="resultsText"></pre>
      <div class="actions">
        <button class="btn btn-download" onclick="downloadCsv()">Download CSV</button>
        <button class="btn btn-lock" onclick="closeResults()">Close</button>
      </div>
    </div>
  </div>

  <footer>
    <p>¬© 2025 Barford Golf Society | Scores & Handicap Calculator</p>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  // === SUPABASE CONNECTION ===
  const SUPABASE_URL = "https://tzzkgfehtnuizamzlbgr.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR6emtnZmVodG51aXphbXpsYmdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0MzY5ODAsImV4cCI6MjA3ODAxMjk4MH0.2mf4RMbJJvPo0NApywlrDyHuqAMfMyEWxgOS2ZSP4KQ";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  // === GLOBALS ===
  const PASSWORD = "westbrom1997";
  let unlocked = false;
  let currentRound = 1;
  const maxRounds = 7;

  let players = [];
  // Per-player arrays (index by player -> array[1..7])
  let hcpHistory = [];   // starting HCP for each round (frozen after Calculate)
  let pointsHistory = [];
  let adjHistory = [];
  let nextHcpLive = [];  // latest computed next HCP (for display/propagation)
  let calcLocked = false;

  // === HELPERS ===
  const rIndex = r => Math.max(1, Math.min(maxRounds, r)); // clamp 1..7

  function ensurePlayerArrays(idx){
    if(!hcpHistory[idx]) hcpHistory[idx] = Array(maxRounds+1).fill(null);
    if(!pointsHistory[idx]) pointsHistory[idx] = Array(maxRounds+1).fill(null);
    if(!adjHistory[idx]) adjHistory[idx] = Array(maxRounds+1).fill(null);
    if(typeof nextHcpLive[idx] !== "number") nextHcpLive[idx] = 0;
  }

  // === LOAD PLAYERS AND ROUND ENTRIES ===
  async function loadPlayers() {
    const { data, error } = await supabase.from("scores").select("*").order("id",{ascending:true});
    if (error) { console.error(error); return; }
    if (data?.length) {
      players = data.map(r=>r.player);
      // initialize arrays
      hcpHistory = []; pointsHistory = []; adjHistory = []; nextHcpLive = [];
      players.forEach((_,i)=>{
        ensurePlayerArrays(i);
        // Seed nextHcpLive with their current stored handicap as a starting point
        const startH = data[i].handicap ?? 0;
        nextHcpLive[i] = startH;
        // Also set Round 1 starting HCP if present in DB
        hcpHistory[i][1] = startH;
      });
    } else {
      players = [];
    }
    await loadRoundEntries(); // fill histories from per-round table
    renderLeaderboard();
  }

  async function loadRoundEntries(){
    // Fetch all saved per-round entries
    const { data, error } = await supabase
      .from("round_entries")
      .select("*")
      .order("round",{ascending:true});
    if(error){ console.warn("round_entries fetch error:", error.message); return; }
    if(!data) return;

    // rebuild histories
    const playerIndex = Object.fromEntries(players.map((p,i)=>[p,i]));
    data.forEach(row=>{
      const i = playerIndex[row.player];
      if(i===undefined) return;
      ensurePlayerArrays(i);
      const rd = rIndex(row.round);
      hcpHistory[i][rd] = typeof row.hcp === "number" ? row.hcp : (hcpHistory[i][rd] ?? 0);
      pointsHistory[i][rd] = (typeof row.points === "number") ? row.points : pointsHistory[i][rd];
      adjHistory[i][rd] = (typeof row.adj === "number") ? row.adj : adjHistory[i][rd];
    });

    // Reconstruct latest nextHcpLive by walking rounds in order
    players.forEach((_,i)=>{
      // Start from round 1 hcp if available, else 0
      let rolling = hcpHistory[i][1] ?? 0;
      for(let rd=1; rd<=maxRounds; rd++){
        const adj = adjHistory[i][rd];
        if(typeof adj === "number"){
          // This round had calculation; next HCP after this round:
          rolling = Math.max(0, Math.round((hcpHistory[i][rd] ?? rolling) + adj));
          // If next round has no starting HCP saved yet, seed it for convenience
          if(rd+1<=maxRounds && hcpHistory[i][rd+1]===null){
            hcpHistory[i][rd+1] = rolling;
          }
        }else{
          // No calc yet; if starting HCP not set, keep whatever we have
          if(hcpHistory[i][rd]===null) hcpHistory[i][rd]=rolling;
        }
      }
      nextHcpLive[i] = rolling;
    });
  }

  // === THEME TOGGLE ===
  function toggleTheme(){
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('bgsTheme',document.body.classList.contains('dark-mode')?'dark':'light');
  }
  if(localStorage.getItem('bgsTheme')==='dark')document.body.classList.add('dark-mode');

  // === BLUR LOGIC ===
  function showBlurOverlay(show){
    const overlay=document.getElementById("blurOverlay");
    overlay.classList.toggle("active",show);
  }
  function updateBlur(){
    showBlurOverlay(!unlocked && currentRound>=6);
  }

  // === LOCK / UNLOCK ===
  function unlockInputs(){
    const pw=document.getElementById("pwInput").value;
    if(pw!==PASSWORD)return alert("Incorrect password!");
    unlocked=true;
    alert("Scores unlocked");
    renderLeaderboard();updateBlur();
  }
  function lockInputs(){
    unlocked=false;
    alert("Scores locked");
    renderLeaderboard();updateBlur();
  }

  // === STABLEFORD ADJ ===
  function stablefordAdj(pts){
    if(pts>=43)return -3;
    if(pts>=38)return -2;
    if(pts>=31)return -1;
    if(pts>=26)return 0;
    if(pts>=21)return +1;
    if(pts>=16)return +2;
    return +3;
  }

  // === UPSERT ROUND ENTRY (safe even if unique constraint exists) ===
  async function upsertRoundEntry(player, round, hcp, points, adj){
    // Try upsert with onConflict first; if schema lacks constraint, fallback to manual upsert.
    let resp = await supabase.from("round_entries")
      .upsert([{player, round, hcp, points, adj}], { onConflict: "player,round" });
    if(resp.error){
      // Fallback: try update then insert if none updated
      const { error: updErr, count } = await supabase
        .from("round_entries")
        .update({ hcp, points, adj })
        .eq("player", player).eq("round", round).select("*", { count: "exact", head: true });
      if(updErr || !count){
        await supabase.from("round_entries").insert([{ player, round, hcp, points, adj }]);
      }
    }
  }

  // === CALCULATE HANDICAPS (per-round, frozen HCP) ===
  async function calculateHandicaps(){
    if(!unlocked)
      return alert("‚õ≥ Stop trying to add your score ‚Äî it doesn‚Äôt change the fact you‚Äôre bad at golf!");
    if(calcLocked)return alert("Already calculating ‚Äî give it a sec.");
    calcLocked=true;
    setTimeout(()=>calcLocked=false,1200);

    // Gather points and starting HCPs for this round
    const valid=[];for(let i=0;i<players.length;i++){
      const v=parseInt(document.getElementById(`points_${i}`)?.value);
      if(!isNaN(v))valid.push(v);
    }
    const top=valid.length?Math.max(...valid):null;

    // For each player, freeze this round's HCP if not already frozen, compute adj & next
    for(let i=0;i<players.length;i++){
      const rd = currentRound;
      ensurePlayerArrays(i);

      // Starting HCP shown/entered for THIS round:
      let startHcp = hcpHistory[i][rd];
      const hcpInput = document.getElementById(`hcp_${i}`);
      if(startHcp===null || startHcp===undefined){
        // Not frozen yet; take the input (or last rolling) and freeze it
        const inputVal = parseFloat(hcpInput?.value);
        startHcp = isNaN(inputVal) ? (nextHcpLive[i] ?? 0) : inputVal;
        hcpHistory[i][rd] = startHcp;
      }else{
        // Already frozen; make sure UI reflects it
        if(hcpInput) hcpInput.value = startHcp;
      }

      // Points this round:
      const pts = parseInt(document.getElementById(`points_${i}`)?.value);
      if(isNaN(pts)){
        // save HCP freeze only; clear points/adj for this round
        pointsHistory[i][rd] = null;
        adjHistory[i][rd] = null;
        await upsertRoundEntry(players[i], rd, startHcp, null, null);
        continue;
      }

      pointsHistory[i][rd] = pts;

      // Calculate adj; top score gets extra -1
      let adj = stablefordAdj(pts);
      if(top!==null && pts===top) adj -= 1;
      adjHistory[i][rd] = adj;

      // Next HCP after this round (not retroactive)
      const newH = Math.max(0, Math.round(startHcp + adj));
      nextHcpLive[i] = newH;

      // Persist round entry
      await upsertRoundEntry(players[i], rd, startHcp, pts, adj);
    }

    renderLeaderboard();

    if(currentRound===maxRounds){
      setTimeout(showFinalResults,300);
    }
  }

  // === TOTALS (Best 5) from pointsHistory ===
  function calculateTotals(){
    return players.map((name,i)=>{
      const scores = pointsHistory[i] ? pointsHistory[i].slice(1) : [];
      const clean = scores.filter(v=>typeof v==="number");
      const total = clean.sort((a,b)=>b-a).slice(0,5).reduce((a,b)=>a+b,0);
      return {i,name,total};
    }).sort((a,b)=>b.total-a.total);
  }

  // === RENDER ===
  function renderLeaderboard(){
    const tbody=document.getElementById("playersTable");
    tbody.innerHTML="";
    const totals=calculateTotals();

    totals.forEach((p,rank)=>{
      const i = p.i;
      const rd = currentRound;
      ensurePlayerArrays(i);

      // The Round X HCP shown is the frozen HCP for that round, or a prefill (last nextHcpLive)
      let roundHcp = hcpHistory[i][rd];
      if(roundHcp===null || roundHcp===undefined){
        // Prefill from previous round's result to assist, but not frozen until Calculate
        // Find previous round with a known nextHcp or frozen HCP
        const prev = rd>1 ? (hcpHistory[i][rd-1]!==null && typeof adjHistory[i][rd-1]==="number"
                              ? Math.max(0, Math.round(hcpHistory[i][rd-1] + adjHistory[i][rd-1]))
                              : hcpHistory[i][rd-1]) : hcpHistory[i][1];
        roundHcp = (typeof prev==="number") ? prev : (nextHcpLive[i] ?? 0);
      }

      const scoreVal = pointsHistory[i][rd] ?? "";
      const adj = (typeof adjHistory[i][rd]==="number") ? ((adjHistory[i][rd]>0?"+":"")+adjHistory[i][rd]) : "";
      const nextDisplay = (typeof adjHistory[i][rd]==="number")
        ? Math.max(0, Math.round(roundHcp + adjHistory[i][rd]))
        : 0; // Next HCP starts at 0 until Calculate

      const dnp = (scoreVal==="") ? "checked" : "";
      const readOnly = unlocked ? "" : "readonly";

      const tr=document.createElement("tr");
      tr.innerHTML=`
        <td>${rank===0?"ü•á":rank===1?"ü•à":rank===2?"ü•â":rank+1}</td>
        <td>${p.name}</td>
        <td><input type="number" id="hcp_${i}" value="${roundHcp}" ${readOnly}></td>
        <td><input type="number" id="points_${i}" value="${scoreVal}" ${readOnly}></td>
        <td id="adj_${i}">${adj}</td>
        <td id="newHcp_${i}">${nextDisplay}</td>
        <td id="season_${i}">${p.total}</td>
        <td><input type="checkbox" id="dnp_${i}" disabled ${dnp}></td>`;
      tbody.appendChild(tr);
    });

    const totalsNow=calculateTotals();
    if(totalsNow.length){
      const leader=totalsNow[0];
      document.getElementById("leaderboard").textContent=
        `üèÜ Leader: ${leader.name} ‚Äî ${leader.total} pts | Round ${currentRound} of ${maxRounds}`;
    }
    document.getElementById("roundHeader").textContent=`Round ${currentRound} of ${maxRounds}`;
    const hcpHeaderEl = document.getElementById("hcpHeader");
    if(hcpHeaderEl) hcpHeaderEl.textContent = `Round ${currentRound} HCP`;

    updateBlur();
  }

  // === ROUND NAVIGATION ===
  function nextRound(){
    if(currentRound<maxRounds){
      currentRound++;
      renderLeaderboard();
    }
  }
  function prevRound(){
    if(currentRound>1){currentRound--;renderLeaderboard();}
  }

  // === ADD PLAYER ===
  async function addPlayer(){
    if(!unlocked)return alert("Enter password to add a player.");
    const name=prompt("Enter new player name:");
    if(!name)return;
    await supabase.from("scores").insert([{
      player:name,round:1,handicap:0,points:0,next_handicap:0,adj:0,total:0,dnp:false
    }]);
    await loadPlayers();
  }

  // === FINAL RESULTS POPUP (modal) ===
  function showFinalResults(){
    const totals=calculateTotals();
    const lines = totals.map((t,i)=>`${i+1}. ${t.name} ‚Äî ${t.total} pts`).join("\n");
    document.getElementById("resultsText").textContent = lines;
    document.getElementById("resultsBackdrop").classList.add("active");
  }
  function closeResults(){
    document.getElementById("resultsBackdrop").classList.remove("active");
  }

  // === RESET SEASON ===
  async function resetSeason(){
    const pw=prompt("Enter password to reset season:");
    if(pw!==PASSWORD)return alert("Incorrect password!");
    if(!confirm("Are you sure you want to reset all scores and handicaps to 0?"))return;

    // wipe round_entries for all players
    const { error: delErr } = await supabase.from("round_entries").delete().neq("player",""); // simple wipe
    if(delErr) console.warn("round_entries wipe:", delErr.message);

    // reset local state
    hcpHistory=[]; pointsHistory=[]; adjHistory=[]; nextHcpLive=[];
    players.forEach((_,i)=>ensurePlayerArrays(i));
    currentRound=1;
    alert("Season has been reset!");
    renderLeaderboard();
  }

  // === DOWNLOAD CSV (all rounds) ===
  function downloadCsv(){
    // Build a CSV with per-round details
    let header = ["Player","Round","RoundHCP","Points","Adj","NextHCPAfterRound","Total(Best5)"];
    let lines = [header.join(",")];

    const totalsMap = Object.fromEntries(calculateTotals().map(p=>[p.name,p.total]));

    players.forEach((name,i)=>{
      for(let rd=1; rd<=maxRounds; rd++){
        const h = hcpHistory[i]?.[rd];
        const pts = pointsHistory[i]?.[rd];
        const adj = adjHistory[i]?.[rd];
        const nextAfter = (typeof h==="number" && typeof adj==="number") ? Math.max(0, Math.round(h + adj)) : "";
        lines.push([name, rd, h ?? "", pts ?? "", (adj ?? ""), nextAfter, (rd===maxRounds? (totalsMap[name]||0) : "")].join(","));
      }
    });

    const blob=new Blob([lines.join("\n")],{type:"text/csv"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);a.download="BarfordGolfScores_AllRounds.csv";a.click();
  }

  // === INITIALISE ===
  loadPlayers();
  </script>
</body>
</html>
